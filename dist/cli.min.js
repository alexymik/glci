#!/usr/bin/env node
'use strict';

var yaml = require('js-yaml');
var Docker = require('dockerode');
var git = require('nodegit');
var chalk = require('chalk');
var yargs = require('yargs/yargs');
var require$$0 = require('yargs/helpers');
var dotenv = require('dotenv');
var cp = require('cp');
var path = require('path');
var fs = require('fs');
var require$$1 = require('perf_hooks');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var yaml__default = /*#__PURE__*/_interopDefaultLegacy(yaml);
var Docker__default = /*#__PURE__*/_interopDefaultLegacy(Docker);
var git__default = /*#__PURE__*/_interopDefaultLegacy(git);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var yargs__default = /*#__PURE__*/_interopDefaultLegacy(yargs);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var dotenv__default = /*#__PURE__*/_interopDefaultLegacy(dotenv);
var cp__default = /*#__PURE__*/_interopDefaultLegacy(cp);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);

var preDefined = async job => {
  var _job$stage;

  const repository = await git__default['default'].Repository.open(".");
  const branch = await repository.getCurrentBranch();
  const headCommit = await repository.getHeadCommit();
  const branchName = branch.name().replace("refs/heads/", "");
  return {
    CI: true,
    CI_API_V4_URL: "https://gitlab.example.com/api/v4/",
    CI_BUILDS_DIR: "/",
    CI_COMMIT_BEFORE_SHA: "0000000000000000000000000000000000000000",
    CI_COMMIT_DESCRIPTION: headCommit.message().split("\n")[0].length < 100 ? headCommit.message().split("\n").slice(1).join("\n") : headCommit.message(),
    CI_COMMIT_MESSAGE: headCommit.message(),
    CI_COMMIT_REF_NAME: branchName,
    CI_COMMIT_REF_PROTECTED: false,
    CI_COMMIT_REF_SLUG: branchName.toLowerCase().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
    CI_COMMIT_SHA: headCommit.sha(),
    CI_COMMIT_SHORT_SHA: headCommit.sha().slice(0, 8),
    CI_COMMIT_BRANCH: branchName,
    CI_COMMIT_TITLE: headCommit.message().split("\n")[0],
    CI_COMMIT_TIMESTAMP: headCommit.time(),
    CI_CONCURRENT_ID: "42",
    CI_CONCURRENT_PROJECT_ID: "42",
    CI_CONFIG_PATH: ".gitlab-ci.yml",
    CI_DEBUG_TRACE: false,
    // TODO: figure it out
    CI_DEFAULT_BRANCH: "master",
    CI_JOB_ID: "42",
    CI_JOB_IMAGE: job.image,
    CI_JOB_MANUAL: false,
    CI_JOB_NAME: job.name,
    CI_JOB_STAGE: (_job$stage = job.stage) !== null && _job$stage !== void 0 ? _job$stage : "test",
    CI_NODE_INDEX: job.index,
    CI_NODE_TOTAL: 1,
    CI_PIPELINE_ID: 42,
    CI_PIPELINE_IID: 42,
    CI_PIPELINE_SOURCE: "unknown",
    CI_PIPELINE_TRIGGERED: true,
    CI_PROJECT_DIR: job.workdir,
    CI_PROJECT_ID: 42,
    CI_PROJECT_NAME: "glci-name-stub",
    CI_PROJECT_NAMESPACE: "glci-namespace-stub",
    CI_PROJECT_ROOT_NAMESPACE: "glci-root-namespace-stub",
    CI_PROJECT_PATH: "glci-namespace-stub/glci-name-stub",
    CI_PROJECT_PATH_SLUG: "glci-namespace-stub-glci-name-stub",
    CI_PROJECT_REPOSITORY_LANGUAGES: "",
    CI_PROJECT_TITLE: "Local CI Title Stub",
    CI_PROJECT_VISIBILITY: "internal",
    CI_RUNNER_DESCRIPTION: "Local CI Runner",
    CI_RUNNER_ID: 42,
    CI_RUNNER_REVISION: "42.42.42",
    CI_RUNNER_SHORT_TOKEN: "42424242",
    CI_RUNNER_VERSION: "42.42.42",
    CI_SERVER: true,
    CI_SERVER_NAME: "Local CI",
    CI_SERVER_REVISION: "42.42.42",
    CI_SERVER_VERSION: "42.42.42",
    CI_SERVER_VERSION_MAJOR: 42,
    CI_SERVER_VERSION_MINOR: 42,
    CI_SERVER_VERSION_PATCH: 42,
    GITLAB_CI: true,
    GITLAB_USER_EMAIL: "gitlab@glci.com",
    GITLAB_USER_ID: 42
  };
};

var _ARGV$onlyJobs;
const {
  hideBin
} = require$$0__default['default'];
const {
  performance
} = require$$1__default['default']; // ----- globals -----

const JOBS_NAMES = [];
const DEFAULT = {};
const ARTIFACTS = []; // ----- constants -----

const ARGV = yargs__default['default'](hideBin(process.argv)).argv;
const ONLY_JOBS = (_ARGV$onlyJobs = ARGV["only-jobs"]) !== null && _ARGV$onlyJobs !== void 0 && _ARGV$onlyJobs.split ? ARGV["only-jobs"].split(",") : undefined;
const DOTENV_PATH = path__default['default'].resolve(process.cwd(), ".env");
const ENV = fs__default['default'].existsSync(DOTENV_PATH) ? dotenv__default['default'].parse(fs__default['default'].readFileSync(DOTENV_PATH)) : {};
const LOCAL_CI_DIR = ARGV.dir ? path__default['default'].resolve(process.cwd(), ARGV.dir) : path__default['default'].resolve(process.cwd(), ".glci"); // keys unusable as job name because reserved

const RESERVED_JOB_NAMES = ["image", "services", "stages", "types", "before_script", "after_script", "variables", "cache", "include"]; // keys that can appear in "default" key
// https://docs.gitlab.com/ee/ci/yaml/README.html#global-defaults

const GLOBAL_DEFAULT_KEY = ["image", "before_script", "after_script", "cache", "variables"]; // ----- main -----

async function execCommands(workdir, container, commands, onerror) {
  for (const command of commands) {
    console.log(chalk__default['default'].bold(chalk__default['default'].green(command)));
    let exec = null;
    let stream = null;

    try {
      exec = await container.exec({
        Cmd: ["sh", "-c", command],
        AttachStdout: true,
        AttachStderr: true,
        WorkingDir: workdir
      });
      stream = await exec.start();
    } catch (err) {
      await onerror(err, container);
    }

    await new Promise((resolve, reject) => {
      stream.on("end", async () => {
        const inspect = await exec.inspect();
        if (inspect.ExitCode !== 0) reject();
        resolve();
      });
      container.modem.demuxStream(stream, process.stdout, {
        write: err => console.error(chalk__default['default'].red(err.toString()))
      });
    });
  }
}

async function main() {
  if (!fs__default['default'].existsSync(path__default['default'].resolve(process.cwd(), ".gitlab-ci.yml"))) {
    throw "No .gitlab-ci.yml file found in current working directory.";
  }

  const gitlabci = fs__default['default'].readFileSync(path__default['default'].resolve(process.cwd(), ".gitlab-ci.yml"), "utf8");
  let ci = yaml__default['default'].load(gitlabci);

  if (typeof ci !== "object") {
    throw "Your .gitlab-ci.yml file is invalid.";
  } // checking mandatory keys


  if (!("stages" in ci)) {
    throw "No 'stages' keyword found in your .gitlab-ci.yml.";
  } //const docker = new Docker();
  // hacky way to do docker over ssh
  // const agent = ssh({
  //   host: "127.0.0.1",
  //   port: 2222,
  //   username: "vagrant",
  //   privateKey: fs.readFileSync(
  //     "/Users/maxime.dubourg/.vagrant.d/insecure_private_key"
  //   ),
  // });
  // const docker = new Docker({
  //   protocol: "http",
  //   username: "vagrant",
  //   agent,
  // });


  const docker = new Docker__default['default']();

  try {
    await docker.version();
  } catch (err) {
    console.error(chalk__default['default'].red(err));
    console.error("Docker daemon does not seem to be running.");
    process.exit(1);
  }

  const repository = await git__default['default'].Repository.open(".");
  const commit = await repository.getHeadCommit();
  const sha = commit.sha().slice(0, 7);
  const tree = await commit.getTree();
  const walker = tree.walk();
  let projectFiles = []; // listing .git project files

  walker.on("entry", entry => {
    const path = entry.path();

    if (fs__default['default'].existsSync(path)) {
      projectFiles.push(path);
    }
  });
  walker.start(); // adding .git to project files

  projectFiles.push(".git"); // handling inclusion of other yaml files

  if ("include" in ci) {
    let included = "";

    for (const entry of ci.include) {
      if ("local" in entry) {
        included += fs__default['default'].readFileSync(path__default['default'].join(process.cwd(), entry.local)) + "\n";
      } else {
        throw "Only 'local' includes are supported at the moment.";
      }
    }

    ci = { ...ci,
      ...yaml__default['default'].load(included)
    };
  } // figuring out default values


  for (const key of GLOBAL_DEFAULT_KEY) {
    DEFAULT[key] = ci.default ? ci.default[key] : ci[key];
  } // diff. actual jobs from reserved "config" keys


  for (const key of Object.keys(ci)) {
    if (!RESERVED_JOB_NAMES.includes(key)) {
      JOBS_NAMES.push(key);
    }
  } // running stages by order of definition in the "stages" key


  for (const stage of ci.stages) {
    const jobs = JOBS_NAMES.filter(job => {
      var _ci$job$stage;

      return ((_ci$job$stage = ci[job].stage) !== null && _ci$job$stage !== void 0 ? _ci$job$stage : "test") === stage;
    }).filter(job => ONLY_JOBS ? ONLY_JOBS.includes(job) : true);
    let index = 0; // as default value for a job is "test"
    // see https://docs.gitlab.com/ee/ci/yaml/README.html#stages

    for (const name of jobs) {
      var _job$image, _job$image2, _DEFAULT$image, _ref, _job$cache$policy, _job$cache, _DEFAULT$cache, _job$cache$paths, _job$cache2, _DEFAULT$cache$paths, _DEFAULT$cache2, _job$stage;

      index++;
      const now = performance.now();
      const job = ci[name]; // pushing artifacts paths in global artifacts

      if ("artifacts" in job) {
        for (const file of (_job$artifacts$paths = job.artifacts.paths) !== null && _job$artifacts$paths !== void 0 ? _job$artifacts$paths : []) {
          var _job$artifacts$paths;

          if (!ARTIFACTS.includes(file)) {
            ARTIFACTS.push(file);
          }
        }
      }

      const workdir = `/${sha}`;
      const image = (_job$image = job.image) !== null && _job$image !== void 0 && _job$image.name ? job.image.name : ((_job$image2 = job.image) !== null && _job$image2 !== void 0 ? _job$image2 : (_DEFAULT$image = DEFAULT.image) === null || _DEFAULT$image === void 0 ? void 0 : _DEFAULT$image.name) ? DEFAULT.image.name : DEFAULT.image;
      const cache = {
        policy: (_ref = (_job$cache$policy = (_job$cache = job.cache) === null || _job$cache === void 0 ? void 0 : _job$cache.policy) !== null && _job$cache$policy !== void 0 ? _job$cache$policy : (_DEFAULT$cache = DEFAULT.cache) === null || _DEFAULT$cache === void 0 ? void 0 : _DEFAULT$cache.policy) !== null && _ref !== void 0 ? _ref : "pull-push",
        paths: ((_job$cache$paths = (_job$cache2 = job.cache) === null || _job$cache2 === void 0 ? void 0 : _job$cache2.paths) !== null && _job$cache$paths !== void 0 ? _job$cache$paths : Array.isArray(job.cache)) ? job.cache : Array.isArray(DEFAULT.cache) ? DEFAULT.cache : (_DEFAULT$cache$paths = (_DEFAULT$cache2 = DEFAULT.cache) === null || _DEFAULT$cache2 === void 0 ? void 0 : _DEFAULT$cache2.paths) !== null && _DEFAULT$cache$paths !== void 0 ? _DEFAULT$cache$paths : []
      };
      let artifactsFiles = ARTIFACTS; // filtering to bind artifacts from specified jobs only

      if (job.dependencies) {
        artifactsFiles = ARTIFACTS.filter(file => job.dependencies.some(jobName => {
          var _ci$jobName$artifacts, _ci$jobName$artifacts2;

          return (_ci$jobName$artifacts = ci[jobName].artifacts) === null || _ci$jobName$artifacts === void 0 ? void 0 : (_ci$jobName$artifacts2 = _ci$jobName$artifacts.paths) === null || _ci$jobName$artifacts2 === void 0 ? void 0 : _ci$jobName$artifacts2.includes(file);
        }));
      } // filtering artifacts files against cache files


      artifactsFiles = artifactsFiles.filter(file => !cache.paths.includes(file));
      const preDefined$1 = await preDefined({ ...job,
        name,
        index,
        image,
        workdir
      });
      const variables = { ...preDefined$1,
        ...ENV,
        ...DEFAULT.variables,
        ...job.variables
      };
      const headline = `Running job "${chalk__default['default'].yellow(name)}" for stage "${(_job$stage = job.stage) !== null && _job$stage !== void 0 ? _job$stage : "test"}"`;
      const delimiter = new Array(headline.length).fill("-").join("");
      console.log(chalk__default['default'].bold(delimiter));
      console.log(chalk__default['default'].bold(headline));
      console.log(chalk__default['default'].bold(delimiter + "\n"));

      const onerror = async (err, container) => {
        if (err) console.error(chalk__default['default'].red(err));
        console.error(chalk__default['default'].red("✘"), ` - ${name}\n`);
        if (container) await container.stop();
        process.exit(1);
      };

      try {
        // pulling the image to use
        await new Promise((resolve, reject) => docker.pull(image, {}, (err, stream) => {
          if (err) reject(err);
          let downloading = false;
          docker.modem.followProgress(stream, () => {
            if (!downloading) {
              console.log(chalk__default['default'].bold(`${chalk__default['default'].blue("ℹ")} - Using existing image "${image}"`));
            }

            resolve();
          }, progress => {
            if (!downloading && progress.status === "Downloading") {
              downloading = true;
              console.log(chalk__default['default'].bold(`${chalk__default['default'].blue("ℹ")} - Pulling image "${image}"...`));
            }
          });
        }));
      } catch (err) {
        await onerror(err);
      } // copying project files inside .glci to allow non-read-only bind


      for (const file of projectFiles) {
        if (!fs__default['default'].existsSync(path__default['default'].join(LOCAL_CI_DIR, sha, path__default['default'].dirname(file)))) {
          fs__default['default'].mkdirSync(path__default['default'].join(LOCAL_CI_DIR, sha, path__default['default'].dirname(file)), {
            recursive: true
          });
        }

        cp__default['default'].sync(`${path__default['default'].resolve(process.cwd(), file)}`, path__default['default'].join(LOCAL_CI_DIR, sha, file));
      }

      const config = {
        Image: image,
        Tty: true,
        Env: Object.keys(variables).map(key => `${key}=${variables[key]}`),
        HostConfig: {
          AutoRemove: true,
          Binds: [// binding the copy of project directory files
          `${path__default['default'].join(LOCAL_CI_DIR, sha)}:${workdir}`, // ...projectFiles.map(
          //   (p) =>
          //     `${path.resolve(
          //       path.join(LOCAL_CI_DIR, sha),
          //       p
          //     )}:${workdir}/${p}`
          // ),
          // binding cache directories / files
          ...cache.paths.map(p => `${LOCAL_CI_DIR}/${p}:${p.startsWith("/") ? p : workdir + "/" + p}${cache.policy === "pull" ? ":ro" : ""}`), // binding artifacts directories / files
          ...artifactsFiles.map(p => {
            var _job$artifacts, _job$artifacts$paths2;

            return `${LOCAL_CI_DIR}/${p}:${p.startsWith("/") ? p : workdir + "/" + p}${(_job$artifacts = job.artifacts) !== null && _job$artifacts !== void 0 && (_job$artifacts$paths2 = _job$artifacts.paths) !== null && _job$artifacts$paths2 !== void 0 && _job$artifacts$paths2.includes(p) ? "" : ":ro"}`;
          })]
        }
      };
      console.log(config);
      let container = null;

      try {
        container = await docker.createContainer(config);
      } catch (err) {
        await onerror(err);
      }

      try {
        await container.start();
      } catch (err) {
        await onerror(err, container);
      }

      try {
        // running before_script
        if (job.before_script || DEFAULT.before_script) {
          var _job$before_script;

          const commands = (_job$before_script = job.before_script) !== null && _job$before_script !== void 0 ? _job$before_script : DEFAULT.before_script;
          await execCommands(workdir, container, commands, onerror);
        } // running script


        await execCommands(workdir, container, job.script, onerror); // running after_script

        if (job.after_script || DEFAULT.after_script) {
          var _job$after_script;

          const commands = (_job$after_script = job.after_script) !== null && _job$after_script !== void 0 ? _job$after_script : DEFAULT.after_script;
          await execCommands(workdir, container, commands, onerror);
        } // stopping container when finishing


        await container.stop();
      } catch (err) {
        await onerror(err, container);
      }

      const duration = ((performance.now() - now) / 1000).toFixed(2);
      console.log(chalk__default['default'].green("✓"), ` - ${name} (${duration}s)\n`);
    }
  }
}

if (ARGV.help || ARGV.h) {
  console.log(`glci: Ease GitLab CI Pipelines set-up by running your jobs locally in Docker containers.

glci options:
    --only-jobs [jobs]: limiting the jobs to run to the comma-separated list of jobs name given
    -h:                 display this help message

Disclaimer: this is a helper tool aiming to facilite the process of setting up GitLab CI Pipelines. glci **does NOT** aim to replace any other tool.
`);
} else {
  main();
}

var glci = {};

module.exports = glci;
